use std::collections::{BTreeMap, HashMap};
use std::marker::PhantomData;

use private::BorderAdjacencySelector;

use crate::core::common::*;
use crate::gen::collapse::private::AdjacencyTable;
use crate::id::*;

/// Trait shared by analyzers producing [`AdjacencyRules`].
pub trait Analyzer<D, Data, Grid>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
    Grid: GridMap<D, Data>,
{
    /// Retrieves the adjacency rules.
    fn adjacency(&self) -> &AdjacencyRules<D, Data>;
    /// Retrieves the collection of all `tile_type_id` which have their rules generated.
    fn tiles(&self) -> &[u64];
    /// Analyzes provided grid map of [`IdentifiableTileData`]-implementing tiles.
    fn analyze(&mut self, map: &Grid);
}

/// Adjacency rules for singular collapse algorithm.
#[derive(Debug)]
pub struct AdjacencyRules<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    inner: AdjacencyTable<D>,
    id_type: PhantomData<Data>,
}

impl<D, Data> Clone for AdjacencyRules<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
            id_type: PhantomData::<Data>,
        }
    }
}

impl<D, Data> Default for AdjacencyRules<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    fn default() -> Self {
        Self {
            inner: AdjacencyTable::<D>::default(),
            id_type: PhantomData::<Data>,
        }
    }
}

impl<D, Data> AdjacencyRules<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    /// Method for manual addition of the adjacency between two tiles.
    ///
    /// It is always symmetrical, so the if the `tile` can be adjacent to `adjacent_tile` in the given `direction`,
    /// the `adjacent_tile` can be adjacent to `tile` in the opposite one.
    pub fn add_adjacency(&mut self, tile: &Data, adjacent_tile: &Data, direction: D::Dir) {
        self.add_adjacency_raw(tile.tile_type_id(), adjacent_tile.tile_type_id(), direction)
    }

    fn add_adjacency_raw(&mut self, tile_id: u64, adjacent_id: u64, direction: D::Dir) {
        self.inner.insert_adjacency(tile_id, direction, adjacent_id);
    }

    pub(crate) fn inner(&self) -> &AdjacencyTable<D> {
        &self.inner
    }
}

/// Analyzer creating exact adjacency rules on basis of sample map.
///
/// Rules generated by it are in general more restrictive than the ones produced by [`BorderAnalyzer`], as the tiles are deemed to be
/// adjacent only if they are adjacent in the sample grid, while the latter can produce more rules based by the borders.
pub struct IdentityAnalyzer<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    tiles: Vec<u64>,
    adjacency_rules: AdjacencyRules<D, Data>,
}

impl<D, Data> Default for IdentityAnalyzer<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    fn default() -> Self {
        Self {
            tiles: Vec::new(),
            adjacency_rules: AdjacencyRules::default(),
        }
    }
}

impl<D, Data> IdentityAnalyzer<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    fn analyze_tile_at_pos<G: GridMap<D, Data>>(&mut self, map: &G, pos: D::Pos) {
        if let Some((pos, tile)) = map.get_tile_at_position(&pos) {
            if !self.tiles.contains(&tile.tile_type_id()) {
                self.tiles.push(tile.tile_type_id());
            }

            for dir in D::Dir::all() {
                if let Some((_, neighbour)) = map.get_neighbour_at(&pos, dir) {
                    self.adjacency_rules.add_adjacency(&tile, &neighbour, *dir)
                }
            }
        }
    }

    pub fn adjacency(&self) -> &AdjacencyRules<D, Data> {
        &self.adjacency_rules
    }
}

impl<D, Data, Grid> Analyzer<D, Data, Grid> for IdentityAnalyzer<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
    Grid: GridMap<D, Data>,
{
    fn analyze(&mut self, map: &Grid) {
        for position in map.get_all_positions() {
            self.analyze_tile_at_pos(map, position);
        }
    }

    fn adjacency(&self) -> &AdjacencyRules<D, Data> {
        &self.adjacency_rules
    }

    fn tiles(&self) -> &[u64] {
        &self.tiles
    }
}

/// Analyzer creating adjacency rules based on the borders between tiles.
///
/// Rules generated by it are more liberal than the ones produced by [`IdentityAnalyzer`], as the tiles are deemed to be adjacent not only
/// if they are adjacent in the sample grid, but the extra step during the process is taken - each tile border is given its unique identifier,
/// and the tile is a viable neighbour option if their borders in given direction have the same identifier.
///
/// This analyzer additionally to analyzing the map, also provides method to add the tile adjacency manually.
pub struct BorderAnalyzer<D, Data, Grid>
where
    D: Dimensionality + BorderAdjacencySelector<D, Data, Grid>,
    Data: IdentifiableTileData,
    Grid: GridMap<D, Data>,
{
    tiles: Vec<u64>,
    adjacency_rules: AdjacencyRules<D, Data>,
    /// TileId key
    inner: HashMap<u64, <D as BorderAdjacencySelector<D, Data, Grid>>::Adjacency>,
    /// BorderId key; (TileId; GridDir)
    border_types: HashMap<u64, Vec<(u64, D::Dir)>>,
    phantom: PhantomData<Grid>,
}

impl<D, Data, Grid> Default for BorderAnalyzer<D, Data, Grid>
where
    D: Dimensionality + BorderAdjacencySelector<D, Data, Grid>,
    Data: IdentifiableTileData,
    Grid: GridMap<D, Data>,
{
    fn default() -> Self {
        Self {
            tiles: Vec::new(),
            adjacency_rules: AdjacencyRules::default(),
            inner: HashMap::new(),
            border_types: HashMap::new(),
            phantom: PhantomData,
        }
    }
}

impl<D, Data, Grid> Analyzer<D, Data, Grid> for BorderAnalyzer<D, Data, Grid>
where
    D: Dimensionality + BorderAdjacencySelector<D, Data, Grid>,
    Data: IdentifiableTileData,
    Grid: GridMap<D, Data>,
{
    fn analyze(&mut self, map: &Grid) {
        self.adjacency_rules = AdjacencyRules::default();
        for position in map.get_all_positions() {
            self.analyze_tile_at_pos(map, position);
        }
        self.generate_adjacency_rules();
    }

    fn adjacency(&self) -> &AdjacencyRules<D, Data> {
        &self.adjacency_rules
    }

    fn tiles(&self) -> &[u64] {
        &self.tiles
    }
}

impl<D, Data, Grid> BorderAnalyzer<D, Data, Grid>
where
    D: Dimensionality + BorderAdjacencySelector<D, Data, Grid>,
    Data: IdentifiableTileData,
    Grid: GridMap<D, Data>,
{
    /// Manually add adjacency between two tiles.
    ///
    /// After addition of new adjacencies, the [`prepare`](Self::prepare) method should be called to generate the rules.
    pub fn add_adjacency(&mut self, tile: &Data, neighbour: &Data, direction: &D::Dir) {
        self.add_adjacency_raw(tile.tile_type_id(), neighbour.tile_type_id(), direction)
    }

    pub fn prepare(&mut self) {
        self.generate_adjacency_rules()
    }

    fn analyze_tile_at_pos(&mut self, map: &Grid, pos: D::Pos) {
        if let Some(tile) = map.get_data_at_position(&pos) {
            if !self.tiles.contains(&tile.tile_type_id()) {
                self.tiles.push(tile.tile_type_id());
            }

            for dir in D::Dir::all() {
                if let Some((_, neighbour)) = map.get_neighbour_at(&pos, dir) {
                    self.add_adjacency_raw(tile.tile_type_id(), neighbour.tile_type_id(), dir);
                }
            }
        }
    }

    fn generate_adjacency_rules(&mut self) {
        let border_ids = self.border_types.keys().copied().collect::<Vec<_>>();

        for border_id in border_ids.iter() {
            let borders = self.border_types.get(border_id).unwrap().clone();

            for half_dir in D::Dir::primary() {
                let first_borders = borders
                    .iter()
                    .filter_map(
                        |(tile, dir)| {
                            if dir == half_dir {
                                Some(*tile)
                            } else {
                                None
                            }
                        },
                    )
                    .collect::<Vec<_>>();
                let second_borders = borders
                    .iter()
                    .filter_map(|(tile, dir)| {
                        if *dir == half_dir.opposite() {
                            Some(*tile)
                        } else {
                            None
                        }
                    })
                    .collect::<Vec<_>>();

                for tile_first in first_borders.iter() {
                    for tile_second in second_borders.iter() {
                        self.adjacency_rules.add_adjacency_raw(
                            *tile_first,
                            *tile_second,
                            *half_dir,
                        );
                        self.adjacency_rules.add_adjacency_raw(
                            *tile_second,
                            *tile_first,
                            half_dir.opposite(),
                        );
                    }
                }
            }
        }
    }

    pub(crate) fn add_adjacency_raw(&mut self, tile_id: u64, adjacent_id: u64, direction: &D::Dir) {
        self.ensure_adjacencies_present_for_tiles(&[tile_id, adjacent_id]);

        match (
            self.get_border_id(&tile_id, direction),
            self.get_border_id(&adjacent_id, &direction.opposite()),
        ) {
            (None, None) => {
                let new_id = self.get_next_border_id();
                self.set_border_id(new_id, tile_id, direction);
                self.set_border_id(new_id, adjacent_id, &direction.opposite());
            }
            (None, Some(id_border)) => {
                self.set_border_id(id_border, tile_id, direction);
            }
            (Some(id_border), None) => {
                self.set_border_id(id_border, adjacent_id, &direction.opposite());
            }
            (Some(id_left), Some(id_right)) => {
                if id_left == id_right {
                    return;
                }
                self.unify_border_id(id_left.max(id_right), id_left.min(id_right));
            }
        }
    }

    fn ensure_adjacencies_present_for_tiles(&mut self, ids: &[u64]) {
        for id in ids {
            if !self.inner.contains_key(id) {
                self.inner.insert(*id, D::Adjacency::default());
            }
        }
    }

    fn set_border_id(&mut self, border_id: u64, tile_id: u64, direction: &D::Dir) {
        self.inner
            .get_mut(&tile_id)
            .unwrap()
            .set_at_dir(direction, border_id);
        self.border_types
            .entry(border_id)
            .or_default()
            .push((tile_id, *direction));
    }

    fn get_border_id(&self, tile_id: &u64, direction: &D::Dir) -> Option<u64> {
        self.inner.get(tile_id).unwrap().get_at_dir(direction)
    }

    fn unify_border_id(&mut self, existing: u64, into: u64) {
        let cache = self.border_types.remove(&existing).unwrap();
        for (tile_id, direction) in cache.iter() {
            self.set_border_id(into, *tile_id, direction);
        }
    }

    fn get_next_border_id(&self) -> u64 {
        if let Some(max_id) = self.border_types.keys().max() {
            *max_id + 1
        } else {
            0
        }
    }
}

// Common trait definition
pub trait TileBordersAdjacency<
    D: Dimensionality,
    Data: IdentifiableTileData,
    Grid: GridMap<D, Data>,
>: Default
{
    fn set_at_dir(&mut self, dir: &D::Dir, border_id: u64);
    fn get_at_dir(&self, dir: &D::Dir) -> Option<u64>;

    // Common implementation can be provided here
    fn has_border_in_direction(&self, dir: &D::Dir) -> bool {
        self.get_at_dir(dir).is_some()
    }
}

// 2D Implementation

pub(crate) mod two_d {
    use super::*;
    use crate::core::two_d::*;

    #[derive(Debug, Clone)]
    pub struct TileBordersAdjacency2D<Data>
    where
        Data: IdentifiableTileData,
    {
        borders: [Option<u64>; 4], // 4 directions in 2D
        phantom: PhantomData<Data>,
    }

    impl<Data> TileBordersAdjacency<TwoDim, Data, GridMap2D<Data>> for TileBordersAdjacency2D<Data>
    where
        Data: IdentifiableTileData,
    {
        fn set_at_dir(&mut self, dir: &Direction2D, border_id: u64) {
            self.borders[dir.as_idx()] = Some(border_id);
        }

        fn get_at_dir(&self, dir: &Direction2D) -> Option<u64> {
            self.borders[dir.as_idx()]
        }
    }

    impl<Data> Default for TileBordersAdjacency2D<Data>
    where
        Data: IdentifiableTileData,
    {
        fn default() -> Self {
            Self {
                borders: [None, None, None, None],
                phantom: PhantomData,
            }
        }
    }

    impl<Data> super::private::BorderAdjacencySelector<TwoDim, Data, GridMap2D<Data>> for TwoDim
    where
        Data: IdentifiableTileData,
    {
        type Adjacency = TileBordersAdjacency2D<Data>;
    }
}

pub(crate) mod three_d {
    use super::*;
    use crate::core::three_d::*;

    // 3D Implementation
    #[derive(Debug, Clone)]
    pub struct TileBordersAdjacency3D<Data>
    where
        Data: IdentifiableTileData,
    {
        borders: [Option<u64>; 6], // 6 directions in 3D
        phantom: PhantomData<Data>,
    }

    impl<Data> TileBordersAdjacency<ThreeDim, Data, GridMap3D<Data>> for TileBordersAdjacency3D<Data>
    where
        Data: IdentifiableTileData,
    {
        fn set_at_dir(&mut self, dir: &Direction3D, border_id: u64) {
            self.borders[dir.as_idx()] = Some(border_id);
        }

        fn get_at_dir(&self, dir: &Direction3D) -> Option<u64> {
            self.borders[dir.as_idx()]
        }
    }

    impl<Data> Default for TileBordersAdjacency3D<Data>
    where
        Data: IdentifiableTileData,
    {
        fn default() -> Self {
            Self {
                borders: [None, None, None, None, None, None],
                phantom: PhantomData,
            }
        }
    }

    impl<Data> super::private::BorderAdjacencySelector<ThreeDim, Data, GridMap3D<Data>> for ThreeDim
    where
        Data: IdentifiableTileData,
    {
        type Adjacency = TileBordersAdjacency3D<Data>;
    }
}

/// Frequency hints for the *adjacency-based* generative algorithm.
///
/// Describes the frequency of occurence of all distinct tiles. Can be generated automatically while analyzing sample
/// maps, or specified manually for each `tile_type_id` via [`set_weight_for_tile`](Self::set_weight_for_tile) method.
#[derive(Debug)]
pub struct FrequencyHints<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    weights: BTreeMap<u64, u32>,
    id_type: PhantomData<(D, Data)>,
}

impl<D, Data> Clone for FrequencyHints<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    fn clone(&self) -> Self {
        Self {
            weights: self.weights.clone(),
            id_type: PhantomData,
        }
    }
}

impl<D, T> Default for FrequencyHints<D, T>
where
    D: Dimensionality,
    T: IdentifiableTileData,
{
    fn default() -> Self {
        Self {
            weights: BTreeMap::new(),
            id_type: PhantomData::<(D, T)>,
        }
    }
}

impl<D, Data> FrequencyHints<D, Data>
where
    D: Dimensionality,
    Data: IdentifiableTileData,
{
    pub fn set_weight_for_data<Tile>(&mut self, data: &Data, weight: u32) {
        let entry = self.weights.entry(data.tile_type_id()).or_default();
        *entry = weight;
    }

    pub fn count_data(&mut self, data: &Data) {
        if let Some(count) = self.weights.get_mut(&data.tile_type_id()) {
            *count += 1;
        } else {
            self.weights.insert(data.tile_type_id(), 1);
        }
    }

    pub(crate) fn get_all_weights_cloned(&self) -> BTreeMap<u64, u32> {
        self.weights.clone()
    }

    pub fn analyze<Grid: GridMap<D, Data>>(&mut self, map: &Grid) {
        for position in map.get_all_positions() {
            let data = map.get_data_at_position(&position).unwrap();
            self.count_data(&data);
        }
    }
}

pub(crate) mod private {
    use super::TileBordersAdjacency;
    use crate::{
        core::common::{Dimensionality, GridMap},
        id::IdentifiableTileData,
    };

    pub trait BorderAdjacencySelector<D, Data, Grid>
    where
        D: Dimensionality,
        Data: IdentifiableTileData,
        Grid: GridMap<D, Data>,
    {
        type Adjacency: TileBordersAdjacency<D, Data, Grid>;
    }
}
